<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<script src="/bjc-r-ita/llab/loader.js" type="text/javascript"></script>
<title>Unit 2 Lab 6 Teacher Guide</title>
</head>
<body>
<h2>Lab 6: Optional Projects</h2>



<!--<h3>Prepare</h3>
		<div>
			<ul>
				<li></li>
			</ul>
		</div>-->
<h3>Lab Pages</h3>
<div>
<ul>
<li>
<strong>Page 1: Automated Fortune Teller.</strong>
<ul>
<li>
<strong>Learning Goals:</strong>
<ul>
<li>
                  Gain more experience in using the <em>list</em> data structure
                </li>
</ul>
</li>
<li>
<strong>Tips:</strong>
<ul>
<li>
                  Students may become very creative by embellishing this project
                  with their own choice of costumes and sounds.
                </li>
</ul>
</li>
</ul>
</li>
<li>
<strong>Page 2: Egyptian Motif.</strong>
<ul>
<li>
<strong>Learning Goals:</strong>
<ul>
<li>
                  Deepen understanding of a <em>variable</em> by using a slider
                  to make a variable vary in real time.
                </li>
</ul>
</li>
<li>
<strong>Tips:</strong>
<ul>
<li>
                  The context is one example of Islamic artistic design, which
                  is often based in pure forms, rather than images of nature.
                </li>
<li>
                  The project ties directly to Unit 1 Lab 3 where
                  <code>pinwheel</code> and <code>rectangle</code> blocks were
                  developed. It could be recommended to students with an
                  interest in art or Islamic culture. You and your students may
                  find <em>Visual Modeling with Logo</em> by James Clayson (MIT
                  Press) an inspiring reference.
                </li>
</ul>
</li>
</ul>
</li>
<li>
<strong>Page 3: Mastermind.</strong>
<p>
            Like Tic-Tac-Toe, this is a yearlong project working toward a
            program that does a good job of guessing. This first step, though,
            just gives the basics of a user interface for two human players.
          </p>
<ul>
<li>
<strong>Learning Goals:</strong>
<ul>
<li>
                  Use <strong>parallelism</strong> and
                  <strong>inter-sprite communication</strong> to display each
                  color, which is handled by a separate sprite. These are steps
                  toward object-oriented programming, about which students who
                  take the AP CS A will learn more next year.
                </li>
</ul>
</li>
<li>
<strong>Tips:</strong>
<ul>
<li>
                  Developing an optimal (human) strategy for Mastermind is an
                  interesting, nontrivial task, which students may enjoy, but
                  it's <em>not</em> part of this lab, so feel free to ask
                  students to do that on their own time.
                </li>
</ul>
</li>
</ul>
</li>
<li>
<strong>Page 4: Modeling Language: Plurals, Part 1.</strong>
<ul>
<li>
<strong>Learning Goals:</strong>
<ul>
<li>
                  Language processing has been one of the classic challenges and
                  stunning successes of computer science. Forty years ago, the
                  idea of a robot like Siri or Amazon Echo that could listen to
                  someone speak, could recognize the words, and could respond
                  usefully was complete science fiction. Computer scientists
                  were certainly working to make it non-fiction, but nothing
                  like it existed. Computers could not even make useful sense
                  out of printed text, let alone spoken words. Today, we almost
                  take tools like that for granted.
                </li>
<li>
                  The reason for mentioning this is that even this small
                  language processing task, though well within the students'
                  capabilities, is challenging. Students analyze the relevant
                  data (words) to find patterns; they subdivide the problem
                  according to those patterns; they use “specialists” to solve
                  specific parts of a problem; and they coordinate those
                  specialized procedures into a solution to the task. The
                  computer science involved is problem decomposition and
                  abstraction.
                </li>
</ul>
</li>
<li>
<strong>Tips:</strong>
<ul>
<li>
                  Students, even in high school, may have questions about what
                  is the correct plural or correct way to spell it. Encourage
                  them to check with each other, but also feel free to ask you.
                  Or just ignore words that they're not yet sure about. One side
                  benefit of this project is that it helps students notice how
                  much they do know and take for granted, and how much work it
                  is for a computer to do what humans do naturally!
                  <em>Students may do this kind of activity in another language
                    if they like. The Take It Further suggests one such
                    investigation. It does not scaffold that investigation, but
                    the reasoning and programming are nearly identical. Students
                    might begin with the experiments and, once they know how the
                    Snap! blocks work, skip to the language of their choice
                    instead of doing English plurals.</em>
</li>
</ul>
</li>
</ul>
</li>
<li>
<strong>Page 5: Modeling Language: Plurals, Part 2.</strong>
<ul>
<li>
<strong>Learning Goals:</strong>
<ul>
<li>
                  The following rule summaries are for your benefit. Don't teach
                  them to students. The rules, themselves, are of no importance.
                  The point of this project is for students to analyze the data
                  they have to discover regularities in it the way computational
                  linguists do, by making a model, seeing if it works, and
                  fixing it if it does not. Here are some things the specialists
                  must do:<br/>
<ul>
<li>
<strong>plural-h</strong> needs to recognize words that
                      end with ch and sh so that it can join es to those. To all
                      other words (for example, ones that end with th) we just
                      join s. To do this, <strong>plural-h</strong> must look at
                      the next-to-last letter of the word.
                    </li>
<li>
<strong>plural-y</strong> also needs to look at the
                      next-to-last letter, in this case to see if it is a vowel.
                      To words like <em>day</em> and <em>boy</em> with vowels
                      before the <em>y</em>, we just <strong>join</strong>
<em>s</em>. For the others, like <em>spy</em> and
                      <em>fly</em>, we remove the y and use
                      <strong>join</strong> to replace it with an <em>i</em> and
                      <em>es</em>.
                    </li>
</ul>
</li>
</ul>
</li>
<li>
<strong>Tips:</strong>
<ul>
<li>
                  You can best contribute to their debugging of a specialist
                  block they think they've finished just by asking if they have
                  tried hard to find a word that it gets wrong.
                </li>
</ul>
</li>
</ul>
</li>
<li>
<strong>Page 5: Modeling Language: Plurals, Part 2.</strong>
<ul>
<li>
<strong>Learning Goals:</strong>
<ul>
<li>
                  The following rule summaries are for your benefit. Don't teach
                  them to students. The rules, themselves, are of no importance.
                  The point of this project is for students to analyze the data
                  they have to discover regularities in it the way computational
                  linguists do, by making a model, seeing if it works, and
                  fixing it if it does not. Here are some things the specialists
                  must do:<br/>
<ul>
<li>
<strong>plural-h</strong> needs to recognize words that
                      end with ch and sh so that it can join es to those. To all
                      other words (for example, ones that end with th) we just
                      join s. To do this, <strong>plural-h</strong> must look at
                      the next-to-last letter of the word.
                    </li>
<li>
<strong>plural-y</strong> also needs to look at the
                      next-to-last letter, in this case to see if it is a vowel.
                      To words like <em>day</em> and <em>boy</em> with vowels
                      before the <em>y</em>, we just <strong>join</strong>
<em>s</em>. For the others, like <em>spy</em> and
                      <em>fly</em>, we remove the y and use
                      <strong>join</strong> to replace it with an <em>i</em> and
                      <em>es</em>.
                    </li>
</ul>
</li>
</ul>
</li>
<li>
<strong>Tips:</strong>
<ul>
<li>
                  You can best contribute to their debugging of a specialist
                  block they think they've finished just by asking if they have
                  tried hard to find a word that it gets wrong.
                </li>
<li>
                  There are two Take It Further exercises, both on interesting
                  subjects. The first one introduces recursion, and the second
                  one introduces data-directed programming. The recursion one
                  asks for a specialist to handle words that end with a space
                  character. That's a rather artificial thing to want, because
                  typically you make a list of words using
                  <code>split ... by word</code> and that removes spaces. If
                  students complain about that, you can agree but tell them to
                  just do it anyway because it ends with a pleasant surprise.
                  <p>
                    Data-directed programming means to put the knowledge about
                    how to handle different cases, in this case the last letters
                    of words, into a data structure rather than directly into a
                    script. It's a very important form of abstraction in the
                    real world.
                  </p>
<p>
                    The data-directed programming exercise includes a bunch of
                    repetitive data entry, for the key-value pairs. It's
                    possible to save a lot of effort by duplicating the
                    <code>list</code> block that makes one key-value pair, then
                    in the copy, right-click the block inside the gray ring and
                    select "relabel." That will let you choose a replacement
                    block from a menu. You might want to teach that to any
                    students who take on this exercise.
                  </p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<strong>Page 6: Making a Kaleidoscope.</strong>
<ul>
<li>
<strong>Learning Goals:</strong>
<ul>
<li>
                  Practice creating multiple sprites and using events to trigger
                  activity across sprites.
                </li>
<li>
                  Use arithmetic operators to control sprite movements on the
                  Snap<em>!</em> stage.
                </li>
<li>Practice use of predicates and conditionals.</li>
</ul>
</li>
<li>
<strong>Tips:</strong>
<ul>
<li>
                  There are multiple ways to get an inverse value, such as
                  <code>(-1) × (mouse x)</code> or
                  <code>(0) – (mouse x)</code> (or just
                  <code>( ) – (mouse x)</code>). If students have
                  difficulty determining which values to invert to get the
                  desired effects, you might suggest they set the stage
                  background to a grid by selecting the stage-button in the
                  sprite corral in the lower right, selecting "Backgrounds..."
                  from the Snap<em>!</em> File menu, and importing the "XY
                  Grid." Students may also find it helpful to turn on the
                  watchers for the <code>mouse x</code> and
                  <code>mouse y</code> reporters.<br/>
<img alt="'mouse x' and 'mouse y' reporters in Sensing palette with the checkbox checked beside each one" class="indent" src="/bjc-r-ita/img/2-complexity/mouse-watchers.png" title="'mouse x' and 'mouse y' reporters in Sensing palette with the checkbox checked beside each one"/>
<img alt="Image of the Snap! stage with x and y axes marked, two watchers on the stage labeled 'mouse x: 72' and 'mouse y: -34', and the mouse pointer showing in the lower right quadrant at the stage location (72, -34). The origin is labeled 'X:0,Y:0' and there are horizontal and vertical grid lines marking increments of 100. The point where the x-axis intersects the left side of the stage is labeled 'X:-240,Y:0' and the point where it intersects the right side is labeled 'X:240,Y:0'. The point where the y-axis intersects the top of the stage is labeled 'X:0,Y:180' and the point where it intersects the bottom is labeled 'X:0,Y:-180'." class="indent" src="/bjc-r-ita/img/2-complexity/mouse-watchers-on-stage.png" title="Image of the Snap! stage with x and y axes marked, two watchers on the stage labeled 'mouse x: 72' and 'mouse y: -34', and the mouse pointer showing in the lower right quadrant at the stage location (72, -34). The origin is labeled 'X:0,Y:0' and there are horizontal and vertical grid lines marking increments of 100. The point where the x-axis intersects the left side of the stage is labeled 'X:-240,Y:0' and the point where it intersects the right side is labeled 'X:240,Y:0'. The point where the y-axis intersects the top of the stage is labeled 'X:0,Y:180' and the point where it intersects the bottom is labeled 'X:0,Y:-180'."/>
</li>
<li>
                  In
                  <a href="/bjc-r-ita/cur/programming/1-introduction/5-follow-the-leader/1-following-sprites.html?topic=nyc_bjc%2F1-intro-loops.topic&amp;course=bjc4nyc.html&amp;novideo&amp;noassignment" title="Unit 1 Lab 5 Page 1: Sprite Following the Mouse">Unit 1 Lab 5 Page 1: Sprite Following the Mouse</a>, students used the <code>go to (mouse-pointer)</code> block
                  to follow the mouse, and that is one way to code the first
                  sprite here. But for the second, third, and fourth sprites
                  that mirror the first, students will need to use
                  <code>go to x: ( ) y: ( )</code>.
                </li>
<li>
                  If students end up with a sprite that only draws for only a
                  split second instead of the whole time the mouse is held down,
                  check that they have unchecked the "draggable" box as
                  described on the page.
                </li>
</ul>
</li>
</ul>
</li>

<!--OLD STUFF
                    <ul>
						<li>Like Tic-Tac-Toe, this is a yearlong project working toward a program that does a good job of guessing. This first step, though, just gives the basics of a user interface for two human players. </li>
						<li>The learning goal in this stage of the project is about <strong>parallelism</strong> and <strong>inter-sprite communication</strong>, since the display of each color  is handled by a separate sprite. These things are steps toward object-oriented programming, about which students who take the AP CS A will learn more next year.</li>
						<li>Developing an optimal (human) strategy for Mastermind is an interesting, nontrivial task, which students will enjoy, but it's <em>not</em> part of this lab, so feel free to ask students to do that on their own time.</li>
					</ul>
				</li>
                <li>
					<strong>Page 4: Tic-Tac-Toe Using Sprites.</strong>
					<ul>
						<li>
							<strong>Learning Goals:</strong>
							<ul>
                       			<li>Understand that there <em>are</em> often very different ways to solve a problem.</li>
                        		<li>Appreciate the important CS concept of &quot;parallelism,&quot;&mdash;the fact that multiple processes can be running at the same time (in this case, multiple sprites remaining simultaneously &quot;aware&quot; and waiting for a click).</li>
							</ul>
						</li>
						<li>
							<strong>Tips:</strong>
							<ul>
                        		<li>Later when students extend Tic Tac Toe to check for legal moves, to check for wins, and ultimately to  have the machine play competently, the machine will need to keep a record of each move. The approach in Lab 4 required the programmer to design a way to sense where on the screen a player moved; in this alternative version, the squares of the Tic Tac Toe board are <strong><em>click-conscious </em></strong> sprites, thus eliminating the need for the programmer to compute the board cell numbers from the coordinates of the mouse click.  This approach takes advantage of a capability of Snap<em>!</em> that is not in all programming languages&mdash;clones&mdash;a sophisticated and valuable abstraction that  simplifies the programmer's task in languages that provide it.</li>
							</ul>
						</li>
                        <li>
							<strong>Goals:</strong>
							<ul>
                            	<li>Explore programming in the context of game design.</li>
								<li>Build the first phase of a large program with multiple levels of abstraction.</li>
								<li>Learn about the advantages of using the "cloning" feature of Snap<em>!</em> as an alternative to creating and keeping track of multitudes of sprites with identical properties and behaviors.</li>

                                <li>Learn how to use nesting of looping blocks to create a grid of objects.</li>
                                <li>Gain dexterity in game programming on the way to developing a game AI (Artificial Intelligence.)</li>
							</ul>
						</li>
                        <li>
                        	<strong>Tips:</strong>
							<ul>
                            	<li>Phase 1 of the Tic Tac Toe game is a rather simple implementation of the Human versus Human game.  It may be a good idea to give the students an <a href="/bjc-r-ita/cur/programming/2-complexity/new/6-newTTT-overview.html">overview</a> of the three phases of the project, so they have a sense of direction for the overall project.</li>-->
<!-- <li>Most students will find the use of "cloning" initially challenging and may not even understand at first why it is being used.  Be sure to have them study the <a class="run" href="/bjc-r-ita/prog/2-complexity/U2-CloningExample.xml">"cloning example"</a> given thoroughly and complete the task given there (making rows of Alonzo clones) prior to moving on with Tic Tac Toe.  Motivate the use of "cloning" as a speedy alternative to creating and keeping track of 9 individual square sprites making up the game board.</li>
                                <li>When using clones in Snap<em>!</em> it is essential that the program is terminated by pressing the red stop button (next to the green flag.)  Otherwise, clones created during a previous run will not be deleted and in the next press of the green flag, these clones may end up creating their own clones, exponentially growing the size of the clone population and leading to undesired effects.  This point is made in a comment in the <a class="run" href="/bjc-r-ita/prog/2-complexity/U2-CloningExample.xml">"cloning example"</a> but may need to be emphasized.</li>
                                <li>Students may need some help understanding the use of the <code>mod</code> operator in determining whether a number is odd or even.  Remind them that <code>mod</code> is simply a "remainder" reporter when the first input is divided by the second.  Give them some examples such as: 7 <code>mod</code> 2 equals 1, because, the remainder when 7 is divided by 2 is 1. 6 <code>mod</code> 2 equals 0, because, the remainder when 6 is divided by 2 is 0. </li>
                            </ul>
                        </li>-->
</ul>
</div>
<h3>Solutions</h3>
<div w3-include-html="/bjc-r-ita/utilities/includes/2-solutions.txt"></div>
</body>
</html>
