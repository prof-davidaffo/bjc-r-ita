<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<script src="/bjc-r-ita/llab/loader.js" type="text/javascript"></script>
<title>Unit 8 Lab 5 Teacher Guide</title>
</head>
<body>
<h2>Lab 5: Pascal's Triangle (Optional Lab)</h2>
<p>
<strong>Pascal's Triangle.</strong> Students build a block to compute
      values in Pascal's Triangle, a branched recursive function. The code
      closely follows the idea that each number in the triangle is the sum of
      two numbers above it. The project includes some discussion of the
      efficiency of the recursion, and some options for improving it.
    </p>

<h3>Lab Pages</h3>
<div>
<ul>
<li>
<strong>Page 1: Pascal's Triangle.</strong>
<ul>
<li>
<strong>Learning Goal:</strong> Understand branched recursion and
              functions.
            </li>

<li>
<strong>Tips:</strong>
<ul>
<li>
                  Many students will make errors about the numbers in each row,
                  because of the different indexing involved. It is helpful to
                  tell students that the "first" number in the <em>n</em>th row
                  is <em>n</em>. (The "<em>zeroth</em>" number is 1.) Even so,
                  expect many debugging issues to come up around improper
                  indexing.
                </li>
<li>
                  For students to write the general recursion here, it is very
                  helpful to give multiple numeric examples like the ones used.
                  More numeric examples are better than trying to explain the
                  generalization directly, because that gives away the code
                  students will write.
                </li>
<li>
                  Students will make errors by ignoring the base cases, notably
                  the 1s at the end of a given row. This base case is necessary
                  or an indexing error may occur.
                </li>
</ul>
</li>
</ul>
</li>
<li>
<strong>Page 2: Pascal's Triangle and Efficiency.</strong>
<ul>
<li>
<strong>Learning Goal:</strong> Understand that the running time
              for <code>pascal</code> can differ significantly depending on the
              algorithm used.
            </li>
<li>
<strong>Tips:</strong>
<ul>
<li>
                  Students may think something is broken when calling
                  <code>pascal</code> with high inputs: this is the effect of
                  the massive recursion. Including a visible counter variable
                  can show students that things are working. However, you'll
                  need to watch for the difference between a long recursion, and
                  an infinite one caused by an error in base cases.
                </li>
<li>
                  Advanced students focusing on memoization may decide to scrap
                  the recursion for iteration, and this is fine; encourage them
                  to use recursion if they can figure out how to do so. (Don't
                  let them think that the inefficiency is
                  <em>because of</em> recursion. We could write inefficient
                  iterative code, or efficient recursive code.) The memoization
                  function will track the list of known values, use it when one
                  is available, and record a new value when not available. For a
                  simpler version of memoization, you could ask students to
                  build an efficient calculator of Fibonacci numbers using this
                  concept.
                </li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h3>Solutions</h3>
<div w3-include-html="/bjc-r-ita/utilities/includes/8-solutions.txt"></div>
</body>
</html>
