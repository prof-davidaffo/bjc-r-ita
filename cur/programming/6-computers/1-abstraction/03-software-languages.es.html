<!DOCTYPE html>

<html lang="es">
<head>
<meta charset="utf-8"/>
<script src="/bjc-r-ita/llab/loader.js" type="text/javascript"></script>
<title>Unidad 6 Laboratorio 1: Jerarquía de abstracción computacional, Página 3</title>
</head>
<body>
<h2>Dominio del software: Lenguajes de programación</h2>
<div class="learn"><strong>En esta pánina</strong>, considerarás por qué hay diferentes lenguajes de programación y verás algunas de las formas en que los lenguajes difieren.</div>
<p>JavaScript, Python, Snap<em>!</em>, C++, Java, Scheme, Prolog... ¿Por qué hay tantos lenguajes de programación? ¿Por qué no elegimos el mejor, o diseñamos uno nuevo y mejor, y nos atenemos a él?</p>
<p>Algunos lenguajes tienen propósitos muy limitados; estos se llaman lenguajes con <em>propósito especial</em>. Por ejemplo, Microsoft Word tiene un lenguaje de programación incorporado llamado "macros de Word" que solo sirve para generar datos y dar formato a un documento. Así como, HTML (Lenguaje de marcado de hipertexto) es solo para estructurar páginas web.</p>
<p><em> </em>Los lenguajes de <em>propósito general</em> no tienen un propósito específico. En cierto sentido, estos idiomas son todos iguales: si un algoritmo puede ser expresado en un idioma, puede ser expresado en todos ellos. Se incluyen varias características básicas en casi todos los idiomas, incluidos los operadores aritméticos (<code>+</code>, <code>-</code>, <code>×</code>, <code>÷</code>) y operadores booleanos (<code>y</code>, <code>o</code>, <code>no</code>). Las diferencias entre los idiomas se refieren principalmente a <em>niveles de abstracción.</em></p>
<h3>Lenguajes de alto y bajo nivel</h3>
<img alt="diagrama de lenguajes de programación comunes enumerados en orden de nivel de abstracción; hay una flecha vertical de doble cabeza a la derecha que indica que la primera fila de lenguajes (Snap!, Scheme, Prolog, Ruby, Lisp) son 'lenguajes de alto nivel', la segunda fila (JavaScript, Python, Java, Alice, Scratch) se encuentra en el medio, y la tercera fila (C, C++) son 'lenguajes de bajo nivel'" class="imageRight noshadow" src="/bjc-r-ita/img/6-computers/language-continuum.png" title="diagrama de lenguajes de programación comunes enumerados en orden de nivel de abstracción; hay una flecha vertical de doble cabeza a la derecha que indica que la primera fila de lenguajes (Snap!, Scheme, Prolog, Ruby, Lisp) son 'lenguajes de alto nivel', la segunda fila (JavaScript, Python, Java, Alice, Scratch) se encuentra en el medio, y la tercera fila (C, C++) son 'lenguajes de bajo nivel'" width="400"/>
<p>Un <em>lenguaje de nivel alto</em> (como Snap<em>!</em> o Scheme) incluye muchas abstracciones incorporadas que hacen más fácil centrarse en el problema que se quiere resolver en lugar de en cómo funciona el hardware de la computadora. Un <em>lenguaje de bajo nivel </em>(como C) tiene menos abstracciones, requiriendo que sepas mucho sobre la arquitectura de tu computadora para escribir un programa.</p>
<h4 class="box-head">¿Por qué los programadores usan lenguajes de alto nivel?</h4>
<p>Los lenguajes de nivel alto pueden producir programas más <em>seguros</em> —los que son menos propensos a tener errores—porque las abstracciones manejan detalles desordenados que pueden hacer fracasar a los programadores. </p>
<div class="endnote">
<p>Los lenguajes de nivel alto reducen los errores en el uso de la memoria. Los lenguajes más antiguos y de bajo nivel requerían que el programador manejara el uso de la memoria de la computadora con instrucciones que dijeran "consígueme un bloque de memoria lo suficientemente grande para contener 100 números" y otras instrucciones que dijeran "bien, ya terminé de usar este bloque de memoria; puede ser asignado para algún otro propósito."</p>
<p>Es una molestia en la que hay que pensar, y a los programadores humanos no se les da bien esto. En los lenguajes de bajo nivel, un error muy común es que una parte del programa diga "He terminado con este bloque de memoria" mientras que otra parte del programa lo sigue usando. Los lenguajes de alto nivel se encargan de esto por nosotros usando una técnica llamada <em>recolección de basura</em> que pone a la computadora a cargo de saber cuándo un bloque de memoria ya no está en uso.</p>
</div>
<p>Los lenguajes de alto nivel también pueden hacer la programación mucho más conveniente porque ofrecen más abstracciones. Un ejemplo son las <em>funciones de orden más alto</em> (como <code>mapear</code>, <code>mantener</code>, <code>combinar</code> y <code>para cada</code>), que permiten al programador escribir un código más corto y limpio.</p>
<div class="forYouToDo" id="first">
<ol>
<li>
<!-- Question 1 -->
<div class="assessment-data" hasinlinefeedback="true" identifier="Identify this higher order function." maxchoices="1" responseidentifier="ri1" shuffle="false" type="multiplechoice">
<div class="prompt">
                            Este código es similar a un procedimiento de orden superior que has aprendido.
                            <img alt="Habla con tu compañero" class="inline" src="/bjc-r-ita/img/icons/talk-with-your-partner.png" title="Habla con tu compañero"/>
                            Identifica el procedimiento que este código imita:<br/>
<img alt="variables de programa (resultado) (índice); fijar el parámetro (resultado) a (lista); fijar el parámetro (índice) a (0); repetir (longitud de (palabras)){incrementar (índice) en (1); añadir (unir (elemento (índice) de (palabras)) s) a (resultado)}; reportar (resultado)" class="indent" src="/bjc-r-ita/img/6-computers/hard-way.png" title="variables de programa (resultado) (índice); fijar el parámetro (resultado) a (lista); fijar el parámetro (índice) a (0); repetir (longitud de (palabras)){incrementar (índice) en (1); añadir (unir (elemento (índice) de (palabras)) s) a (resultado)}; reportar (resultado)"/>
<div class="endnote">
<ul>
<li>Aprendiste acerca de <code>para cada</code> en <a href="/bjc-r-ita/cur/programming/2-complexity/2-data-structures-art/3-traversing-list.es.html?topic=nyc_bjc%2F2-conditionals-abstraction.es.topic&amp;course=bjc4nyc.es.html&amp;novideo&amp;noassignment" title="Unidad 2 Laboratorio 2: Comprobación de cada respuesta del cuestionario">Unidad 2 Laboratorio 2: Comprobación de cada respuesta del cuestionario</a>.</li>
<li>Aprendiste acerca de <code>mantener</code> en <a href="/bjc-r-ita/cur/programming/2-complexity/3-predicates/5-keeping-list-items.es.html?topic=nyc_bjc%2F2-conditionals-abstraction.es.topic&amp;course=bjc4nyc.es.html&amp;novideo&amp;noassignment" title="Unidad 2 Laboratorio 3: Mantener elementos de una lista">Unidad 2 Laboratorio 3: <code>Mantener</code> elementos de una lista</a>.</li>
<li>Aprendiste acerca de <code>mapear</code> en <a href="/bjc-r-ita/cur/programming/3-lists/2-contact-list/5-mapping-over-list.es.html?topic=nyc_bjc%2F3-lists.es.topic&amp;course=bjc4nyc.es.html&amp;novideo&amp;noassignment" title="Unidad 3 Laboratorio 2: Transformar cada elemento de la lista">Unidad 3 Laboratorio 2: Transformar cada elemento de la lista</a>.</li>
<li>Aprendiste acerca de <code>combinar</code> en <a href="/bjc-r-ita/cur/programming/2-complexity/4-making-computers-do-math/3-other-math-reporters.es.html?topic=nyc_bjc%2F2-conditionals-abstraction.es.topic&amp;course=bjc4nyc.es.html&amp;novideo&amp;noassignment" title="Unidad 2 Laboratorio 4: Más reporteros matemáticos">Unidad 2 Laboratorio 4: Más reporteros matemáticos</a>.</li>
</ul>
</div>
</div>
<div class="choice" identifier="c1">
<div class="text"><img alt="para cada (palabra) de (palabra) {reportar ((unir (palabra) (s)))}" src="/bjc-r-ita/img/6-computers/for-each-s.png" title="para cada (palabra) de (palabra) {reportar ((unir (palabra) (s)))}"/></div>
<div class="feedback">¿El programa original reporta una lista de palabras o reporta cada palabra por separado? ¿Qué haría esto?</div>
</div>
<div class="choice" identifier="c2">
<div class="text"><img alt="reportar (mantener los elementos donde (unir () (s)) de (palabras))" src="/bjc-r-ita/img/6-computers/keep-s.png" title="reportar (mantener los elementos donde (unir () (s)) de (palabras))"/></div>
<div class="feedback"><code>Mantener</code> toma un predicado (una pregunta) como entrada y reporta una lista de los elementos que hacen que ese predicado sea verdadero.</div>
</div>
<div class="choice" identifier="c3">
<div class="text"><img alt="reportar (mapear (unir () (s)) sobre (palabras))" src="/bjc-r-ita/img/6-computers/map-s.png" title="reportar (mapear (unir () (s)) sobre (palabras))"/></div>
<div class="feedback">¡Correcto!</div>
</div>
<div class="choice" identifier="c4">
<div class="text"><img alt="reportar (combinar los elementos de (unir () (s)) con (palabras))" src="/bjc-r-ita/img/6-computers/combine-s.png" title="reportar (combinar los elementos de (unir () (s)) con (palabras))"/></div>
<div class="feedback"><code>Combinar</code> toma un predicado con dos espacios en blanco (como () + () o unir () ()) como entrada y reporta del resultado de combinar todos los elementos de la lista usando esa función (por ejemplo, sumándolos todos juntos o uniéndolos todos en una cadena de texto).</div>
</div>
<div class="responseDeclaration" identifier="ri1">
<div class="correctResponse" identifier="c4"></div>
</div>
</div>
</li>
</ol>
</div>
<p>
            En C, puedes hacer esto de la forma más larga:<br/>
<img alt="variables de programa (resultado) (índice); asignar a resultado el valor (lista); asignar a índice el valor (0); repetir (longitud de (palabras)){ incrementar índice en (1); añadir (unir (elemento (índice) de (palabras)) s) a (resultado)}; reportar (resultado)" class="indent" src="/bjc-r-ita/img/6-computers/hard-way.png" title="variables de programa (resultado) (índice); asignar a resultado el valor (lista); asignar a índice el valor (0); repetir (longitud de (palabras)){ incrementar índice en (1); añadir (unir (elemento (índice) de (palabras)) s) a (resultado)}; reportar (resultado)"/><br/>
            pero C no te deja tomar una expresión (como <img alt="unir () (s)" class="inline" src="/bjc-r-ita/img/6-computers/join-with-s.png" title="unir () (s)"/> o <img alt="((5) × ( )) + (7)" class="inline" src="/bjc-r-ita/img/6-computers/5-times-blank-plus-7.png" title="((5) × ( )) + (7)"/>) y ponerla en una función de orden superior como <code>mapear</code>:<br/>
<img alt="reportar (mapar (unir () (s)) sobre (palabras))" class="indent" src="/bjc-r-ita/img/6-computers/map-s.png" title="reportar (mapar (unir () (s)) sobre (palabras))"/>
</p>
<h4 class="box-head">¿Por qué los programadores usan lenguajes de bajo nivel?</h4>
<p>La mejor razón para usar lenguajes de bajo nivel es para escribir sistemas operativos (como Windows, Mac OS X, Android, o iOS).  Aprenderás más acerca de sistemas operativos en la página <a href="/bjc-r-ita/cur/programming/6-computers/1-abstraction/05-software-OS.es.html?topic=nyc_bjc%2F6-how-computers-work.es.topic&amp;course=bjc4nyc.es.html&amp;novideo&amp;noassignment" title="The Software Domain: Operating Systems">Dominio de software: Sistemas operativos</a>.</p>
<div class="endnote">
<a data-toggle="collapse" href="#hint-low-level-lang" title="Why else would a programmer use a low-level language?">¿Por que otra razón un programador usaría un lenguaje de bajo nivel?</a>
<div class="collapse" id="hint-low-level-lang">
<p>Los programadores de aplicaciones no suelen decidir "Voy a escribir este programa en un lenguaje de bajo nivel". Puede que simplemente no se den cuenta de que es posible alcanzar niveles más altos de abstracción. Por ejemplo, el hardware de una computadora limita el tamaño de los números que su unidad aritmética puede sumar en un solo paso. Cuatro mil millones—unos diez dígitos—es un límite de tamaño común para los números enteros. Los programadores que utilizan Java, JavaScript, Python, C o C++ pueden pensar que este límite es inevitable. Pero los programadores que usan lenguajes de alto nivel, como Scheme o Common Lisp, saben que pueden hacer aritmética con números de millones o miles de millones de dígitos, limitados solo por el tamaño de la memoria de la computadora. Como verás más adelante, Snap! también tiene una librería que te permite hacer esto.</p>
<p>Las personas a menudo dicen que los diferentes lenguajes de programación son buenos para diferentes tipos de programas, pero excepto para el procesamiento de video en 3D, es difícil imaginar una aplicación que se vería perjudicada por cosas como la recolección de basura o funciones de orden superior. Hay solo unos pocos casos en los que las personas diseñan deliberadamente lenguajes con características que podrían no ser deseadas para algunas aplicaciones. Aquí hay un ejemplo: En Snap!, una cadena de texto de solo dígitos se considera un número; puedes hacer aritmética sobre ella. En un lenguaje para estudiantes, el requerir una conversión explícita entre tipos de datos solo hace más difícil empezar a programar. Pero la mayoría de los lenguajes que no son para principiantes mantienen los dos tipos de datos separados.</p>
<p><em>Los programadores pueden pensar que la abstracción es demasiado lenta.</em> Esto solía ser cierto, y los programadores de videojuegos en 3D todavía necesitan toda la velocidad que puedan conseguir porque sus programas presionan la velocidad de las computadoras modernas. Así que a menudo escriben parte de sus programas, la parte que realmente pone las imágenes en la pantalla, en lenguaje de máquina, solo para la velocidad. Pero la mayoría de los programadores escriben aplicaciones que no fuerzan a las computadoras en absoluto. Cuando envías un correo electrónico o un mensaje de texto, el factor limitante es la velocidad con la que puedes escribir, no la velocidad con la que tu computadora puede ejecutar programas.</p>
<p><em>Código heredado.</em> Los programadores de la industria casi nunca llegan a escribir un programa desde el principio. Mucho más a menudo, mantienen un programa que alguien escribió hace años, y esa persona puede que ya no trabaje para esa compañía. A largo plazo, podría ser mejor reescribir el programa en un lenguaje más moderno, pero a corto plazo, no hay tiempo para hacerlo, así que terminan modificando el código existente en el lenguaje de programación existente.</p>
</div>
</div>
<h4 class="box-head">¿Qué es el lenguaje de máquina?</h4>
<p>Tanto los idiomas de alto como de bajo nivel son utilizados por <em>personas</em> para escribir programas de máquina. El hardware de la computadora entiende una especie de lenguaje de nivel ultra bajo, llamado <em>lenguaje de máquina.</em> Programas especiales llamados <em>compiladores</em> e <em>intérpretes </em>se utilizan para traducir los lenguajes de programación de humanos a lenguaje de máquina para ser ejecutado por la computadora.</p>
<div class="endnote">
<a data-toggle="collapse" href="#hint-compilers" title="Read more about compilers and interpreters">Lee más acerca de compiladores e intérpretes.</a>
<div class="collapse" id="hint-compilers">
<p>Un <em>compilador</em> es un programa que toma un programa de lenguaje de alto o bajo nivel (el <em>código de origen</em>) como entrada y produce un programa de lenguaje de máquina (el <em>código de objeto</em>) como su salida. Una vez producido, el programa de lenguaje de máquina puede ser ejecutado repetidamente sin necesidad de ser compilado de nuevo.</p>
<p>Un <em>intérprete</em> es un programa que toma un programa de alto o bajo nivel como entrada y lleva a cabo las instrucciones del lenguaje de la máquina según sea necesario para ejecutar el programa. No produce un programa de lenguaje de máquina independiente como salida y tendrá que repetir el proceso de nuevo la próxima vez.</p>
<p>
<a data-toggle="collapse" href="#hint-compilers-better" title="Does that mean compilers are better?">¿Eso significa que los compiladores son mejores?</a>
<div class="collapse" id="hint-compilers-better">
<p>Exacto, excepto que el proceso de escribir un programa incluye <em>depuración.</em> Durante la depuración, un intérprete puede ayudar proporcionando información sobre el progreso del programa, como la característica de paso visual en Snap<em>!</em>, y permitiendo pequeños cambios en el programa de origen sin tener que ejecutar un compilador repetidamente. Por ejemplo, en Snap<em>!</em> puedes arrastrar un bloque a un script mientras se está ejecutando, y un compilador no podría permitir eso.</p>
<p>Para programadores profesionales, el mejor arreglo es tener <em>ambos</em> un intérprete y un compilador para el mismo lenguaje. El programador escribe y depura el programa usando un intérprete, y una vez que están seguros de que funciona, lo compilan. Entonces, el compilador puede funcionar lentamente, poniendo mucho esfuerzo en <em>optimizar</em> el código de lenguaje de máquina, para que obtengan el programa compilado lo más rápido posible.</p>
</div>
</p>
</div>
</div>
<div class="forYouToDo">
<ol start="2">
<li>
                    Estas preguntas son similares a las que verán en el examen AP CSP.
                    <!-- Question 1 -->
<div class="assessment-data" hasinlinefeedback="true" identifier="Which is TRUE about a low-level language?" maxchoices="1" responseidentifier="ri1" shuffle="false" type="multiplechoice">
<div class="prompt">
                        	¿Cuáles de las siguientes afirmaciones son correctas sobre un lenguaje de programación de bajo nivel en comparación con un lenguaje de programación de alto nivel?

<ol style="list-style:upper-roman;">
<li>Los programas de lenguaje de bajo nivel son generalmente más difíciles de entender para las personas, que los programas escritos en un lenguaje de alto nivel.</li>
<li>Un lenguaje de bajo nivel proporciona a los programadores más abstracciones que un lenguaje de alto nivel.</li>
<li>Los programas de lenguaje de bajo nivel son generalmente más difíciles de depurar que los programas escritos en un lenguaje de alto nivel.</li>
</ol>
</div>
<div class="choice" identifier="c1">
<div class="text">I solamente.</div>
<div class="feedback">I es verdadera, pero ¿es la única declaración verdadera?</div>
</div>
<div class="choice" identifier="c2">
<div class="text">I y III solamente.</div>
<div class="feedback">Correcto. Ambas afirmaciones son correctas y lo contrario de II es cierto, ya que los lenguajes de alto nivel son más expresivos y capaces de crear abstracciones.</div>
</div>
<div class="choice" identifier="c3">
<div class="text">II y III solamente.</div>
<div class="feedback">Lo contrario de II es verdadera, ya que los lenguajes de alto nivel son más expresivos y capaces de crear abstracciones.</div>
</div>
<div class="choice" identifier="c4">
<div class="text">I, II, y III.</div>
<div class="feedback">Lo contrario de II es verdadera, ya que los lenguajes de alto nivel son más expresivos y capaces de crear abstracciones.</div>
</div>
<div class="responseDeclaration" identifier="ri1">
<div class="correctResponse" identifier="c2"></div>
</div>
</div>
<!-- Question 2 -->
<div class="assessment-data" hasinlinefeedback="true" identifier="Which is TRUE about a program written in a high-level programming language?" maxchoices="1" responseidentifier="ri2" shuffle="false" type="multiplechoice">
<div class="prompt">Un programa está escrito en un lenguaje de programación de alto nivel. Identifica la declaración correcta sobre el programa.</div>
<div class="choice" identifier="c1">
<div class="text">El programa también puede ser escrito en lenguaje de máquina usando código binario, pero entonces será menos fácil de entender por la personas.</div>
<div class="feedback">Correcto. Para los humanos, es muy difícil leer el código binario.</div>
</div>
<div class="choice" identifier="c2">
<div class="text">El programa también puede ser escrito en lenguaje de máquina usando código binario, lo que disminuirá la posibilidad de errores.</div>
<div class="feedback">Los errores probablemente aumentarán ya que es más difícil para los humanos darle sentido al código binario.</div>
</div>
<div class="choice" identifier="c3">
<div class="text">El programa no puede ser escrito en código binario, ya que solo los datos pueden ser representados utilizando la notación binaria.</div>
<div class="feedback">Todo el programa puede ser convertido en código binario. Dicho código es en realidad el único código que una máquina puede entender.</div>
</div>
<div class="choice" identifier="c4">
<div class="text">Partes simples del programa pueden ser escritas en código binario, pero los elementos de control como los condicionales, los bucles deben ser expresados en un lenguaje de programación de alto nivel.</div>
<div class="feedback">Todo el programa puede ser convertido en código binario. Dicho código es en realidad el único código que una máquina puede entender.</div>
</div>
<div class="responseDeclaration" identifier="ri2">
<div class="correctResponse" identifier="c1"></div>
</div>
</div>
</li>
</ol>
</div>
<h3>Legibilidad del código</h3>
<p>
            Una de las características que te da Snap<em>!</em> es que puedes poner el texto del título en el medio de un bloque.<br/>
<div class="sidenote">Escribiste <code>polígono</code> en <a href="/bjc-r-ita/cur/programming/1-introduction/3-drawing/7-graphics-and-art.es.html?topic=nyc_bjc%2F1-intro-loops.es.topic&amp;course=bjc4nyc.es.html&amp;novideo&amp;noassignment" title="Graphics and Art">Unidad 1: Gráficos y arte</a>.</div>
<img alt="polígono, ramas: (30) logitud de la rama: (15)" class="indent" src="/bjc-r-ita/img/6-computers/polygon-30-15.png" title="polígono, ramas: (30) longitud de la rama: (15)"/><br/>
            En comparación con otros lenguajes en los que la función tiene un nombre al principio y luego todas las entradas, este aumenta la claridad y la legibilidad de su función.<br/>
<p class="indent"><code>polígono(30, 15)</code></p>
</p>
<div class="pseudop">
            Además, en un lenguaje basado en texto, cuando ves algo como 3 × 5 + 4, tienes que haber memorizado que la multiplicación viene antes de la suma (así que la respuesta es 19). Si lo quieres de otra manera, tienes que usar paréntesis: 3 × (5 + 4) para obtener 27. En un lenguaje basado en bloques, los bloques muestran lo que se pretendía:
            <img alt="3 × (5 + 4)" class="inline nopadtb" src="/bjc-r-ita/img/6-computers/3-times(5+4).png" title="3 × (5 + 4)"/>. Has aprendido el orden de las operaciones en la clase de matemáticas para +, –, ×, y ÷, pero probablemente no has aprendido el orden de las operaciones para una expresión como esta:
			<pre class="inline">x &amp;&amp; y &lt;&lt; z</pre>. ¿Cómo sabes cuál viene primero?
			<pre class="inline">&amp;&amp;</pre> o
			<pre class="inline">&lt;&lt;</pre>?
        </div>
<div class="endnote">
<a data-toggle="collapse" href="#hint-ooo" title="">¿Cómo lo sabes?</a>
<div class="collapse" id="hint-ooo">
<p>Observa el ejemplo, <a href="https://en.cppreference.com/w/c/language/operator_precedence" target="_blank" title="C Operator Precedence">C Precedencia del operador</a>.</p>
</div>
</div>
<h3>Paralelismo</h3>

<p>Una de las razones para crear nuevos lenguajes de programación es facilitar la escritura de programas <em>paralelos</em> —programas que pueden usar más de un procesador al mismo tiempo. Hoy en 2017, las computadoras y los teléfonos inteligentes tienen chips de procesador <em>multinúcleo</em> que pueden incluir 2, 4, u 8 procesadores todos ejecutándose en código al mismo tiempo. (El número de procesadores aumentará aún más con el tiempo). Las grandes compañías como Google usan el paralelismo aún más; tienen grupos de miles de computadoras, todas trabajando en el mismo programa.</p>

<p>Lenguajes de programación <em>funcional</em> (lenguajes en los que los programadores nunca cambian el valor de una variable) son particularmente adecuados para el paralelismo porque no hay peligro de que un procesador cambie el valor de una variable que otro procesador está usando. A lo largo de este curso te hemos introducido en técnicas de programación funcional siempre que ha sido posible, incluyendo la redacción de reporteros y el uso de funciones de orden superior (<code>mapear</code>, <code>mantener</code>, y <code>combinar</code>).</p>
<div class="endnote">Snap<em>!</em> no es un lenguaje de programación funcional, pero lo sería si los programadores de Snap<em>!</em> eliminaran solo unos pocos procedimientos, incluyendo <code>conjunto</code> (en su lugar, utilizarías variables de entrada de funciones recursivas) y estos cuatro comandos de lista: <code>añadir</code>, <code>borrar</code>, <code>insertar</code>, y <code>reemplazar</code> (en lugar de eso, usarías <code>en frente de</code>, <code>elemento 1 de<span style="font-family: serif;"></span></code> y <code>todo menos el primero de</code> para reportar una nueva lista con diferentes valores en lugar de cambiar la lista anterior).</div>
</body>
</html>
