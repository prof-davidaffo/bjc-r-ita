<!DOCTYPE html>

<html lang="en">
<head>
<meta content="text/html; charset=utf-8" http-equiv="content-type"/>
<script src="/bjc-r-ita/llab/loader.js" type="text/javascript"></script>
<title>Unit 5 Lab 3: Timing Experiments, Page 2</title>
</head>
<body>
<h2>Timing Reporters</h2>



<div class="learn">
<p><strong>On this page</strong>, you will use an <em>algorithm timer</em> to help you compare the efficiency of algorithms.</p>
</div>
<p>Snap<em>!</em> allows us to report how long a program takes to finish.</p>
<div class="forYouToDo" id="first">
<ol>
<li>In the "Sensing" palette, look for the <code>current (</code><var>date</var><code>)</code> reporter. Drag it into the scripting area.  From its input menu, select <var>time in milliseconds</var>.
                </li>
<img alt="current (time in milliseconds) reporting 1454091401280" class="indent" src="/bjc-r-ita/img/5-algorithms/current-time.png" title="current (time in milliseconds) reporting 1454091401280"/>
<li>Click the block several times.  Note the results.</li>
<li>Open the "U5L3-ReporterTimer" project that you saved on the previous page. </li>
<li>Download this library: <a download="" href="/bjc-r-ita/prog/5-algorithms/U5L3functiontimer.xml" target="_blank" title="U5L3functiontimer.xml">U5L3functiontimer.xml</a>, and drag the file into your Snap<em>!</em> application to import it.</li>
</ol>
</div>
<p>At the bottom of the Variables palette, there will now be a block called <code>time function</code>. It takes any reporter (with its inputs filled in), computes the result, and reports <em>how long it took</em> to do the computation (in milliseconds).</p>
<div class="sidenoteBig">You can replace the <code>list from</code> block with any reporter. You can edit <code>time function</code> to see how it works.</div>

<img alt="time function (list from (1) through (1000)) reporting 27" class="indent" src="/bjc-r-ita/img/5-algorithms/timereport.png" title="time function (list from (1) through (1000)) reporting 27"/>
<p>In this example, it took 27 milliseconds to compute the list of integers from 1 to 1000. (The number you see reported will depend on how fast your computer is and what other programs are running on it.)</p>
<p>
            Here's how <code>time function</code> works:<br/>
<img alt="time function (function): (script variables (start time), set (start time) to (current(time in milliseconds)), ignore (call(function)), report(current(time in milliseconds) - start time))" class="indent" src="/bjc-r-ita/img/5-algorithms/time-function-definition.png" style="padding-right:40px" title="time function (function): (script variables (start time), set (start time) to (current(time in milliseconds)), ignore (call(function)), report(current(time in milliseconds) - start time))"/>

<ol type="i">
<li>It creates a variable <var>start time</var> and sets it to the current time.</li>
<li>It calls the reporter that you're trying to time, but it ignores the result.</li>
<li>When the reporter finishes, it gets the current time and subtracts the <var>start time</var> from it.</li>
</ol>
</p>
<div class="forYouToDo">
<ol start="5">
<li>
                    Use <code>time function</code> to compare Morgan and Jasmine's ways of adding the integers from 1 to <em>n</em>. Try it with several different large numbers to see just how different the algorithms are in terms of the time it takes to compute their outputs.<br/>
<div class="sidenoteBig">Morgan and Jasmine’s algorithms solve the same problem but are quite different in efficiency. Imagine the difference when adding the integers from 1 to 1,000,000…</div>
<img alt="time function (betsy way (2000)) reporting 1" class="indent" height="50" src="/bjc-r-ita/img/5-algorithms/time-function-betsy-way-2000-reporting.png" title="time function (betsy way (2000)) reporting 1"/><br/>
<img alt="time function (alphie way (2000)) reporting 187" class="indent" height="50" src="/bjc-r-ita/img/5-algorithms/time-function-alphie-way-2000-reporting.png" title="time function (alphie way (2000)) reporting 187"/>
</li>
<div class="takeNote">The efficiency of an algorithm can make a huge difference. Sometimes, an efficient algorithm is necessary to solve larger instances of a problem.</div>
<li>

                    In <a href="/bjc-r-ita/cur/programming/5-algorithms/1-searching-lists/old/2-improving-search.html?topic=nyc_bjc%2F5-algorithms.topic&amp;course=bjc4nyc.html&amp;novideo&amp;noassignment" title="Analyzing and Improving Searches">Lab 1</a>, you built two reporters that output the position of an element in a list:
                    <div class="vocab">
<p>A <strong>linear search</strong> means searching a list from one item to the next. </p>
<p>A <strong>binary search</strong> means dividing a <em>sorted</em> list into two pieces at each step.</p>
</div>
<ul>
<li>The reporter <code>position of () in unsorted list</code> works for any list by checking element-by-element until it finds a match. This is called a <em>linear search</em> because the program searches from the beginning of the list to the match in a straight line.</li>
<li>The reporter <code>position of () in sorted list</code> works on sorted lists by repeatedly dividing the list into two equal-sized parts and using the middle value to decide which half can contain the match. This is called a <em>binary search</em> because binary means "two" and the algorithm divides the list into two parts.</li>
</ul>
                    Both will work on sorted lists. Compare them for some long sorted lists and make a table of your findings.	 You may have to use very large lists, say 1000 or 2000 items, to get meaningful results. Which algorithm is faster?
                    <div class="endnote">Is the other algorithm ever faster?</div>
</li>
<li>

                    Throughout this course, you've programmed many algorithms. Try timing them. Here are some examples:
					<ul>
<li><img alt="Graph datapoints: ()" height="40" src="/bjc-r-ita/img/3-lists/U3ImageVideoAddendum_img/Graph datapoints.png" title="Graph datapoints: ()"/> (as you saw on <a href="/bjc-r-ita/cur/programming/3-lists/old/4-graphing/2-building-a-grapher.html?topic=nyc_bjc%2F3-lists.topic&amp;course=bjc4nyc.html&amp;novideo&amp;noassignment" title="Unit 3 Lab 4: Building a Graphing App">Unit 3 Lab 4: Building a Graphing App</a>)</li>

<li><img alt="are the numbers in () distinct?" src="/bjc-r-ita/img/5-algorithms/distinctelements.png" title="are the numbers in () distinct?"/> (as you saw on <a href="/bjc-r-ita/cur/programming/5-algorithms/1-searching-lists/7-comparing-search-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic" title="Unit 5 Lab 1: List Processing Algorithms">Unit 5 Lab 1: List Processing Algorithms</a>)</li>
<li><img alt="numbers from () to ()" class="" src="/bjc-r-ita/img/5-algorithms/numbers-from-to.png" title="numbers from () to ()"/> (as you saw on <a href="/bjc-r-ita/cur/programming/5-algorithms/old/3-timing-experiments/1-comparing-algorithms.html?topic=nyc_bjc%2F5-algorithms.topic" title="Unit 5 Lab 3: Comparing Algorithms">Unit 5 Lab 3: Comparing Algorithms</a>)</li>
</ul>
<p>Time your algorithms for varying size inputs and describe the different behaviors you see. Again, use large inputs for meaningful results.</p>
</li>

<li><div class="saveAs"><span class="text">"U5L3-timer"</span><img alt="save your work as U5L3-timer" src="/bjc-r-ita/img/icons/save-this-as.png" title="save your work as U5L3-timer"/></div></li>
</ol>
</div>
</body>
</html>