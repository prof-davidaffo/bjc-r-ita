<!DOCTYPE html>

<html lang="es">
<head>
<meta charset="utf-8"/>
<script src="/bjc-r-ita/llab/loader.js" type="text/javascript"></script>
<title>Unidad 3 Laboratorio 3: Tres en línea, Página 3</title>
</head>
<body>
<h2>Detectar empates</h2>
<div class="learn">
<p>
<strong>En esta página</strong>, comprobarás si hay un empate, es decir,
        cuando no quedan más casillas vacías, pero ningún jugador ha ganado.
      </p>
</div>
<div class="forYouToDo">
<ol start="1">
<li>
          Desarrolla una forma de determinar si los jugadores han empatado y, de
          ser así, haz que el programa notifique a los jugadores.
          <div class="endnote">
<p>
              Snap<em>!</em> tiene una función de orden superior
              <img alt="primer elemento donde () en 'ranura de entrada'" class="inline nopadtb" src="/bjc-r-ita/img/blocks/find-first.es.png" title="primer elemento donde () en 'ranura de entrada'"/>
              que funciona de manera similar a <code>mantener</code>, pero
              reporta solo el primer elemento que se encuentra, por lo que puede
              ser más rápido. <code>Primer elemento donde </code> es equivalente
              a <code>elemento (1) de (mantener)</code>.
            </p>
<p>
<code>Primer elemento donde</code> es una función de orden
              superior como <code>mantener</code>, <code>mapear</code> y
              <code>combinar</code> porque toma una función (un predicado) como
              entrada.
            </p>
<p>
<a data-toggle="collapse" href="#hint-tie-contains" title="Haz clic para obtener una sugerencia sobre el uso de 'primer elemento donde' para detectar empates.">Haz clic para obtener una sugerencia sobre el uso de
                <code>primer elemento donde</code> para detectar empates.</a>
</p>
<div class="collapse" id="hint-tie-contains">
<img alt="primer elemento donde (¿es() un número?) en ()" class="indent" src="/bjc-r-ita/img/3-lists/any-numbers.es.png" title="primer elemento donde (¿es() un número?) en ()"/>
</div>
</div>
</li>
<li>
          Juega un par de veces para probar la función de verificación de
          empates y corrige cualquier error.
        </li>

<li>
          ¿Por qué es importante el orden de las pruebas (para victorias o
          empates)?
          <img alt="Habla con tu compañero" src="/bjc-r-ita/img/icons/talk-with-your-partner-mini.png" title="Habla con tu compañero"/>
</li>
<li>
<img alt="Guarda tu trabajo. Lo usarás más adelante." class="inline" src="/bjc-r-ita/img/icons/save-use-later.es.png" title="Guarda tu trabajo. Lo usarás más adelante."/>
</li>
</ol>
</div>
<div class="ifTime">
<ol start="5">
<li>
          Hay muchas pequeñas mejoras que podrías hacer. Por un lado, cuando un
          jugador gana, es posible que necesites evitar que realice más
          movimientos. ¿Qué más te gustaría cambiar o mejorar?
        </li>
</ol>
</div>
<div class="takeItFurther">
<img alt="Actividades desafiantes" class="imageRight" src="/bjc-r-ita/img/icons/tough-stuff-mini.png" title="Actividades desafiantes"/>
<ol type="A">
<li>
          Tu programa puede ser más inteligente a la hora de detectar empates.
          Si solo hay un cuadrado vacío en el tablero y llenar ese cuadrado con
          el jugador cuyo turno es el siguiente no causaría una victoria,
          entonces los jugadores ya han empatado. El desafío aquí es que tendrás
          que probar para ganar en un tablero que no es el
          <var>tablero</var> actual.
        </li>
<li>
          En lugar de que el objeto diga algo como "X gana", sería más
          satisfactorio para los jugadores dibujar una línea gruesa a través de
          los tres cuadrados que generan una victoria. Esto es un poco
          complicado porque cuando te das cuenta que hay una victoria, ya no
          sabes qué triple la generó. Asegúrate que tu código se mantenga
          legible para otro programador.
        </li>
</ol>
</div>
</body>
</html>
